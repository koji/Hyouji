#!/usr/bin/env node
"use strict";var U=Object.create;var S=Object.defineProperty;var G=Object.getOwnPropertyDescriptor;var q=Object.getOwnPropertyNames;var j=Object.getPrototypeOf,W=Object.prototype.hasOwnProperty;var H=(r,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of q(e))!W.call(r,i)&&i!==t&&S(r,i,{get:()=>e[i],enumerable:!(o=G(e,i))||o.enumerable});return r};var V=(r,e,t)=>(t=r!=null?U(j(r)):{},H(e||!r||!r.__esModule?S(t,"default",{value:r,enumerable:!0}):t,r));const B=require("chalk"),K=require("figlet"),J=require("prompts"),m=require("fs"),T=require("@octokit/core"),F=require("path"),N=require("os"),P=require("crypto"),O=r=>r&&r.__esModule?r:{default:r};function z(r){if(r&&r.__esModule)return r;const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(r){for(const t in r)if(t!=="default"){const o=Object.getOwnPropertyDescriptor(r,t);Object.defineProperty(e,t,o.get?o:{enumerable:!0,get:()=>r[t]})}}return e.default=r,Object.freeze(e)}const n=O(B),Y=O(K),E=O(J),R=z(m),Q=[{type:"password",name:"octokit",message:"Please type your personal token"},{type:"text",name:"owner",message:"Please type your GitHub account"},{type:"text",name:"repo",message:"Please type your target repo name"}],X=[{type:"text",name:"name",message:"Please type new label name"},{type:"text",name:"color",message:'Please type label color without "#" '},{type:"text",name:"description",message:"Please type label description"}],Z={type:"text",name:"name",message:"Please type label name you want to delete"},ee={type:"text",name:"filePath",message:"Please type the path to your JSON file"},te={type:"multiselect",name:"action",message:"Please select an action",choices:[{title:"create a label",value:0},{title:"create multiple labels",value:1},{title:"delete a label",value:2},{title:"delete all labels",value:3},{title:"import JSON",value:4},{title:"Display your settings",value:5},{title:"exit",value:6}]},oe={type:"confirm",name:"value",message:"Do you have a personal token?",initial:!0},re=[{name:"Type: Bug Fix",color:"FF8A65",description:"Fix features that are not working"},{name:"Type: Enhancement",color:"64B5F7",description:"Add new features"},{name:"Type: Improvement",color:"4DB6AC",description:"Improve existing functionality"},{name:"Type: Modification",color:"4DD0E1",description:"Modify existing functionality"},{name:"Type: Optimization",color:"BA68C8",description:"Optimized existing functionality"},{name:"Type: Security Fix",color:"FF8A65",description:"Fix security issue"},{name:"Status: Available",color:"81C784",description:"Waiting for working on it"},{name:"Status: In Progress",color:"64B5F7",description:"Currently working on it"},{name:"Status: Completed",color:"4DB6AC",description:"Worked on it and completed"},{name:"Status: Canceled",color:"E57373",description:"Worked on it, but canceled"},{name:"Status: Inactive (Abandoned)",color:"90A4AF",description:"For now, there is no plan to work on it"},{name:"Status: Inactive (Duplicate)",color:"90A4AF",description:"This issue is duplicated"},{name:"Status: Inactive (Invalid)",color:"90A4AF",description:"This issue is invalid"},{name:"Status: Inactive (Won't Fix)",color:"90A4AF",description:"There is no plan to fix this issue"},{name:"Status: Pending",color:"A2887F",description:"Worked on it, but suspended"},{name:"Priority: ASAP",color:"FF8A65",description:"We must work on it asap"},{name:"Priority: High",color:"FFB74D",description:"We must work on it"},{name:"Priority: Medium",color:"FFF177",description:"We need to work on it"},{name:"Priority: Low",color:"DCE775",description:"We should work on it"},{name:"Priority: Safe",color:"81C784",description:"We would work on it"},{name:"Effort Effortless",color:"81C784",description:"No efforts are expected"},{name:"Effort Heavy",color:"FFB74D",description:"Heavy efforts are expected"},{name:"Effort Normal",color:"FFF177",description:"Normal efforts are expected"},{name:"Effort Light",color:"DCE775",description:"Light efforts are expected"},{name:"Effort Painful",color:"FF8A65",description:"Painful efforts are expected"},{name:"Feedback Discussion",color:"F06293",description:"A discussion about features"},{name:"Feedback Question",color:"F06293",description:"A question about features"},{name:"Feedback Suggestion",color:"F06293",description:"A suggestion about features"},{name:"Docs",color:"000",description:"Documentation"}],ne="Please input your GitHub info",ae=Y.default.textSync("GitHub Label Manager",{font:"Small",horizontalLayout:"default",verticalLayout:"default",width:180,whitespaceBreak:!0}),x="If you don't see action selector, please hit space key.",ie="https://github.com/settings/tokens",w=console.log,$=async(r,e)=>{const t=await r.octokit.request("POST /repos/{owner}/{repo}/labels",{owner:r.owner,repo:r.repo,name:e.name,color:e.color,description:e.description});switch(t.status){case 201:w(n.default.green(`${t.status}: Created ${e.name}`));break;case 404:w(n.default.red(`${t.status}: Resource not found`));break;case 422:w(n.default.red(`${t.status}: Validation failed`));break;default:w(n.default.yellow(`${t.status}: Something wrong`));break}},se=async r=>{re.forEach(async e=>{$(r,e)}),w("Created all labels"),w(n.default.bgBlueBright(x))},ce=(r,e)=>{e.forEach(async t=>{await r.octokit.request("DELETE /repos/{owner}/{repo}/labels/{name}",{owner:r.owner,repo:r.repo,name:t})})},le=async r=>{const e=await r.octokit.request("GET /repos/{owner}/{repo}/labels",{owner:r.owner,repo:r.repo});return e.status===200?await e.data.map(o=>o.name):(w(n.default.red("something wrong")),[])},de=async r=>{const e=await le(r);e.forEach(async t=>{await r.octokit.request("DELETE /repos/{owner}/{repo}/labels/{name}",{owner:r.owner,repo:r.repo,name:t})}),w(""),e.forEach(t=>w(n.default.bgGreen(`deleted ${t}`))),w(n.default.bgBlueBright(x))},fe=async()=>(await E.default(oe)).value,s=console.log,ue=async(r,e)=>{try{if(!R.existsSync(e)){s(n.default.red(`Error: File not found at path: ${e}`));return}const t=R.readFileSync(e,"utf8");let o;try{o=JSON.parse(t)}catch(a){s(n.default.red(`Error: Invalid JSON syntax in file: ${e}`)),s(n.default.red(`Parse error: ${a instanceof Error?a.message:"Unknown error"}`));return}if(!Array.isArray(o)){s(n.default.red("Error: JSON file must contain an array of label objects"));return}const i=[];for(let a=0;a<o.length;a++){const g=o[a];if(typeof g!="object"||g===null){s(n.default.red(`Error: Item at index ${a} is not a valid object`));continue}const d=g;if(!d.name){s(n.default.red(`Error: Item at index ${a} is missing required 'name' field`));continue}if(typeof d.name!="string"){s(n.default.red(`Error: Item at index ${a} has invalid 'name' field (must be a non-empty string)`));continue}if(d.name.trim()===""){s(n.default.red(`Error: Item at index ${a} has empty 'name' field (name cannot be empty)`));continue}if(d.color!==void 0){if(typeof d.color!="string"){s(n.default.red(`Error: Item at index ${a} has invalid 'color' field (must be a string)`));continue}if(d.color.trim()===""){s(n.default.red(`Error: Item at index ${a} has empty 'color' field (color cannot be empty if provided)`));continue}}if(d.description!==void 0&&typeof d.description!="string"){s(n.default.red(`Error: Item at index ${a} has invalid 'description' field (must be a string)`));continue}const v=["name","color","description"],I=Object.keys(d).filter(M=>!v.includes(M));I.length>0&&s(n.default.yellow(`Warning: Item at index ${a} contains unknown fields that will be ignored: ${I.join(", ")}`));const L={name:d.name.trim(),...d.color!==void 0&&{color:d.color.trim()},...d.description!==void 0&&{description:d.description}};i.push(L)}if(i.length===0){s(n.default.red("Error: No valid labels found in JSON file"));return}s(n.default.blue(`Starting import of ${i.length} labels...`)),s("");let c=0,p=0;for(let a=0;a<i.length;a++){const g=i[a],d=`[${a+1}/${i.length}]`;try{s(n.default.cyan(`${d} Processing: ${g.name}`)),await $(r,g),c++}catch(v){p++,s(n.default.red(`${d} Failed to create label "${g.name}": ${v instanceof Error?v.message:"Unknown error"}`))}}s(""),p===0?s(n.default.green(`✅ Import completed successfully! Created ${c} labels.`)):(s(n.default.yellow("⚠️  Import completed with some errors:")),s(n.default.green(`  • Successfully created: ${c} labels`)),s(n.default.red(`  • Failed to create: ${p} labels`)),s(n.default.blue(`  • Total processed: ${i.length} labels`)))}catch(t){s(n.default.red(`Error reading file: ${t instanceof Error?t.message:"Unknown error"}`))}},pe=async()=>[(await E.default(Z)).name],C=class C{static generateMachineKey(){const e=[N.homedir(),process.platform,process.arch,process.env.USER||process.env.USERNAME||"default"].join("|");return P.createHash("sha256").update(e).digest()}static encryptToken(e){try{const t=this.generateMachineKey(),o=P.randomBytes(16),i=P.createCipheriv(this.ALGORITHM,t,o);let c=i.update(e,"utf8",this.ENCODING);return c+=i.final(this.ENCODING),o.toString(this.ENCODING)+":"+c}catch{return console.warn("⚠️  Token encryption failed, storing in plain text"),e}}static decryptToken(e){try{if(!e.includes(":"))return e;const[t,o]=e.split(":");if(!t||!o)return e;const i=this.generateMachineKey(),c=Buffer.from(t,this.ENCODING),p=P.createDecipheriv(this.ALGORITHM,i,c);let a=p.update(o,this.ENCODING,"utf8");return a+=p.final("utf8"),a}catch{return console.warn("⚠️  Token decryption failed, using as plain text"),e}}static isTokenEncrypted(e){return e.includes(":")&&e.length>50}static obfuscateToken(e){if(!e||e.length<8)return"***";const t=e.substring(0,4),o=e.substring(e.length-4),i="*".repeat(Math.min(e.length-8,20));return`${t}${i}${o}`}};C.ALGORITHM="aes-256-cbc",C.ENCODING="hex",C.KEY_LENGTH=32;let h=C;class l extends Error{constructor(e,t,o){super(t),this.type=e,this.originalError=o,this.name="ConfigError"}}class b{constructor(){this.configDir=F.join(N.homedir(),".config","github-label-manager"),this.configPath=F.join(this.configDir,"config.json"),this.fallbackConfigPath=F.join(N.homedir(),".github-label-manager-config.json")}async loadConfig(){const e=[{path:this.configPath,name:"primary"},{path:this.fallbackConfigPath,name:"fallback"}];for(const t of e)try{if(await this.fileExists(t.path)){const o=await this.loadConfigFromPath(t.path);if(o)return o}}catch(o){await this.handleConfigLoadError(o,t.path,t.name)}return null}async loadConfigFromPath(e){try{const t=await m.promises.readFile(e,"utf-8");if(!t.trim())throw new l("CORRUPTED_FILE","Configuration file is empty");let o;try{o=JSON.parse(t)}catch(i){throw new l("CORRUPTED_FILE","Configuration file contains invalid JSON",i)}if(await this.validateConfig(o))return{...o,token:h.decryptToken(o.token)};throw new l("INVALID_FORMAT","Configuration file has invalid format or missing required fields")}catch(t){if(t instanceof l)throw t;const o=t;throw o.code==="EACCES"||o.code==="EPERM"?new l("PERMISSION_DENIED",`Permission denied accessing configuration file: ${e}`,o):o.code==="ENOENT"?new l("FILE_NOT_FOUND",`Configuration file not found: ${e}`,o):new l("UNKNOWN_ERROR",`Unexpected error loading configuration: ${o.message}`,o)}}async handleConfigLoadError(e,t,o){if(e instanceof l)switch(e.type){case"CORRUPTED_FILE":console.warn(`⚠️  Configuration file at ${o} location is corrupted: ${e.message}`),console.warn(`   File: ${t}`),console.warn("   The file will be ignored and you'll be prompted for credentials."),await this.backupCorruptedFile(t);break;case"PERMISSION_DENIED":console.warn(`⚠️  Permission denied accessing configuration file at ${o} location.`),console.warn(`   File: ${t}`),console.warn("   Please check file permissions or run with appropriate privileges.");break;case"INVALID_FORMAT":console.warn(`⚠️  Configuration file at ${o} location has invalid format.`),console.warn(`   File: ${t}`),console.warn("   The file will be ignored and you'll be prompted for credentials."),await this.backupCorruptedFile(t);break;default:console.warn(`⚠️  Failed to load configuration from ${o} location: ${e.message}`),console.warn(`   File: ${t}`)}else console.warn(`⚠️  Unexpected error loading configuration from ${o} location.`),console.warn(`   File: ${t}`)}async backupCorruptedFile(e){try{const t=`${e}.backup.${Date.now()}`;await m.promises.copyFile(e,t),console.warn(`   Corrupted file backed up to: ${t}`)}catch(t){console.warn(`   Could not backup corrupted file: ${t instanceof Error?t.message:"Unknown error"}`)}}async saveConfig(e){const t={...e,token:h.encryptToken(e.token),lastUpdated:new Date().toISOString()},o=JSON.stringify(t,null,2);try{if(await this.ensureConfigDirectory(),await m.promises.writeFile(this.configPath,o,{mode:384}),await this.fileExists(this.fallbackConfigPath))try{await m.promises.unlink(this.fallbackConfigPath)}catch{console.warn(`⚠️  Could not remove old fallback configuration file: ${this.fallbackConfigPath}`)}return}catch(i){const c=i;if(c.code==="EACCES"||c.code==="EPERM")console.warn("⚠️  Permission denied writing to primary configuration location."),console.warn(`   Attempted path: ${this.configPath}`),console.warn("   Trying fallback location...");else{if(c.code==="ENOSPC")throw new l("UNKNOWN_ERROR","Insufficient disk space to save configuration");console.warn(`⚠️  Failed to save configuration to primary location: ${c.message}`),console.warn("   Trying fallback location...")}try{await m.promises.writeFile(this.fallbackConfigPath,o,{mode:384}),console.warn(`✓ Configuration saved to fallback location: ${this.fallbackConfigPath}`);return}catch(p){const a=p;throw a.code==="EACCES"||a.code==="EPERM"?new l("PERMISSION_DENIED","Permission denied: Cannot save configuration to any location. Please check file permissions or run with appropriate privileges.",a):a.code==="ENOSPC"?new l("UNKNOWN_ERROR","Insufficient disk space to save configuration",a):new l("UNKNOWN_ERROR",`Failed to save configuration to any location. Primary error: ${c.message}. Fallback error: ${a.message}`,a)}}}configExists(){try{return require("fs").existsSync(this.configPath)||require("fs").existsSync(this.fallbackConfigPath)}catch{return!1}}getConfigPath(){return require("fs").existsSync(this.configPath)?this.configPath:require("fs").existsSync(this.fallbackConfigPath)?this.fallbackConfigPath:this.configPath}async validateConfig(e){if(!e||typeof e!="object"||!e.token||typeof e.token!="string"||e.token.trim()===""||!e.owner||typeof e.owner!="string"||e.owner.trim()==="")return!1;const t=h.decryptToken(e.token);return!!/^(ghp_|gho_|ghu_|ghs_)[a-zA-Z0-9]{36}$/.test(t)}async validateCredentials(e){try{const{Octokit:t}=await import("@octokit/core"),o=h.decryptToken(e.token),c=await new t({auth:o}).request("GET /user");return c.data.login.toLowerCase()!==e.owner.toLowerCase()?{isValid:!1,error:new l("INVALID_FORMAT",`Token belongs to user '${c.data.login}' but configuration is for '${e.owner}'`)}:{isValid:!0}}catch(t){return t.status===401?{isValid:!1,error:new l("INVALID_FORMAT","GitHub token is invalid or has expired")}:t.status===403?{isValid:!1,error:new l("INVALID_FORMAT","GitHub token has insufficient permissions or rate limit exceeded")}:t.code==="ENOTFOUND"||t.code==="ECONNREFUSED"||t.code==="ETIMEDOUT"?{isValid:!1,error:new l("NETWORK_ERROR","Unable to connect to GitHub API. Please check your internet connection.")}:{isValid:!1,error:new l("UNKNOWN_ERROR",`Failed to validate credentials: ${t.message||"Unknown error"}`)}}}async migrateToEncrypted(){const e=await this.loadConfig();if(e&&!h.isTokenEncrypted(e.token)){console.log("🔒 Migrating configuration to encrypted format...");try{await this.saveConfig(e),console.log("✓ Configuration successfully encrypted")}catch(t){console.warn("⚠️  Failed to encrypt existing configuration:",t instanceof Error?t.message:"Unknown error")}}}async loadValidatedConfig(){const e=await this.loadConfig();if(!e)return{config:null,shouldPromptForCredentials:!0};const t=await this.validateCredentials(e);if(t.isValid)return{config:e,shouldPromptForCredentials:!1};const o={};return t.error&&(console.warn(`⚠️  ${b.getErrorMessage(t.error)}`),t.error.type==="INVALID_FORMAT"&&!t.error.message.includes("Token belongs to user")&&(o.owner=e.owner,console.warn(`   Your GitHub username '${e.owner}' will be preserved.`))),{config:null,shouldPromptForCredentials:!0,preservedData:Object.keys(o).length>0?o:void 0}}async clearConfig(){const e=[];if(await this.fileExists(this.configPath))try{await m.promises.unlink(this.configPath)}catch(t){const o=t;o.code==="EACCES"||o.code==="EPERM"?e.push(`Permission denied removing primary config file: ${this.configPath}`):e.push(`Failed to remove primary config file: ${o.message}`)}if(await this.fileExists(this.fallbackConfigPath))try{await m.promises.unlink(this.fallbackConfigPath)}catch(t){const o=t;o.code==="EACCES"||o.code==="EPERM"?e.push(`Permission denied removing fallback config file: ${this.fallbackConfigPath}`):e.push(`Failed to remove fallback config file: ${o.message}`)}if(e.length>0)throw new l("PERMISSION_DENIED",`Failed to clear configuration: ${e.join("; ")}`)}async ensureConfigDirectory(){try{await m.promises.mkdir(this.configDir,{recursive:!0,mode:448})}catch(e){const t=e;if(t.code==="EEXIST")return;throw t.code==="EACCES"||t.code==="EPERM"?new l("PERMISSION_DENIED",`Permission denied creating configuration directory: ${this.configDir}`,t):t.code==="ENOSPC"?new l("UNKNOWN_ERROR","Insufficient disk space to create configuration directory",t):new l("UNKNOWN_ERROR",`Failed to create configuration directory: ${t.message}`,t)}}async fileExists(e){try{return await m.promises.access(e),!0}catch{return!1}}static getErrorMessage(e){switch(e.type){case"FILE_NOT_FOUND":return"Configuration file not found. You will be prompted to enter your credentials.";case"PERMISSION_DENIED":return"Permission denied accessing configuration file. Please check file permissions or run with appropriate privileges.";case"CORRUPTED_FILE":return"Configuration file is corrupted or contains invalid data. A backup has been created and you will be prompted for new credentials.";case"INVALID_FORMAT":return"Configuration file has invalid format. You will be prompted to enter your credentials again.";case"NETWORK_ERROR":return"Network error occurred while validating credentials. Please check your internet connection.";case"UNKNOWN_ERROR":default:return`An unexpected error occurred: ${e.message}`}}static isRecoverableError(e){return["FILE_NOT_FOUND","CORRUPTED_FILE","INVALID_FORMAT"].includes(e.type)}}const ge=async()=>{var c,p;const r=new b;let e;try{e=await r.loadValidatedConfig()}catch{e={config:null,shouldPromptForCredentials:!0}}if(e.config&&!e.shouldPromptForCredentials){const a=await E.default([{type:"text",name:"repo",message:"Please type your target repo name"}]);return{octokit:new T.Octokit({auth:e.config.token}),owner:e.config.owner,repo:a.repo,fromSavedConfig:!0}}let t=[...Q];if((c=e.preservedData)!=null&&c.owner){const a=t.findIndex(g=>g.name==="owner");a!==-1&&(t[a]={...t[a],initial:e.preservedData.owner})}const o=await E.default(t);if(o.octokit&&o.owner)try{await r.saveConfig({token:o.octokit,owner:o.owner,lastUpdated:new Date().toISOString()}),(p=e.preservedData)!=null&&p.owner&&e.preservedData.owner!==o.owner?console.log("✓ Configuration updated with new credentials"):console.log("✓ Configuration saved successfully")}catch(a){a instanceof l?(console.error(`❌ ${b.getErrorMessage(a)}`),b.isRecoverableError(a)||console.error("   This may affect future sessions. Please resolve the issue or contact support.")):console.warn("⚠️  Failed to save configuration:",a instanceof Error?a.message:"Unknown error")}return{octokit:new T.Octokit({auth:o.octokit}),owner:o.owner,repo:o.repo,fromSavedConfig:!1}},me=async()=>(await E.default(ee)).filePath,he=async()=>await E.default(X),D=async()=>{const r=await E.default(te),{action:e}=r;return e[0]!==void 0?e[0]:99},f=console.log;let u=!0;const k=new b,A=async()=>{console.log(ne),u&&await k.migrateToEncrypted();const r=await ge();if(!r.octokit||!r.owner||!r.repo)throw new Error("Invalid configuration: missing required fields");try{await r.octokit.request("GET /user")}catch(e){if(r.fromSavedConfig)return console.log(n.default.yellow("Saved credentials are invalid. Please provide new credentials.")),await k.clearConfig(),A();throw new Error(`GitHub API authentication failed: ${e instanceof Error?e.message:"Unknown error"}`)}return r},we=async()=>{f(n.default.cyan(`
=== Current Settings ===`));const r=k.getConfigPath();if(f(n.default.blue(`Configuration file path: ${r}`)),!k.configExists()){f(n.default.yellow("No configuration file exists. You will be prompted for credentials on next action."));return}try{const e=await k.loadConfig();if(!e){f(n.default.yellow("Configuration file exists but contains invalid data."));return}if(f(n.default.green(`GitHub account: ${e.owner}`)),e.token){const o=h.isTokenEncrypted(e.token)?"✓ Saved and encrypted":"✓ Saved (plain text)";f(n.default.green(`Personal token: ${o}`));const i=h.decryptToken(e.token),c=h.obfuscateToken(i);f(n.default.blue(`Token preview: ${c}`))}else f(n.default.red("Personal token: ✗ Not saved"));if(e.lastUpdated){const t=new Date(e.lastUpdated);f(n.default.blue(`Last updated: ${t.toLocaleString()}`))}}catch(e){f(n.default.red(`Error reading configuration: ${e instanceof Error?e.message:"Unknown error"}`))}f(n.default.cyan(`========================
`))};let y;const _=async()=>{if(!await fe()){f(n.default.redBright(`Please go to ${ie} and generate a personal token!`));return}if(u){f(ae);try{y=await A(),y.fromSavedConfig&&f(n.default.green(`Using saved configuration for ${y.owner}`))}catch(t){f(n.default.red(`Configuration error: ${t instanceof Error?t.message:"Unknown error"}`));return}}let e=await D();for(;e==99;)e=await D();switch(e){case 0:{const t=await he();$(y,t),u=u&&!1;break}case 1:{se(y),u=u&&!1;break}case 2:{const t=await pe();ce(y,t),u=u&&!1;break}case 3:{de(y),u=u&&!1;break}case 4:{try{const t=await me();t?await ue(y,t):f(n.default.yellow("No file path provided. Returning to main menu."))}catch(t){f(n.default.red(`Error during JSON import: ${t instanceof Error?t.message:"Unknown error"}`))}u=u&&!1;break}case 5:{await we(),u=u&&!1;break}case 6:{console.log("exit"),process.exit(0);break}default:{console.log("invalid input");break}}_()};_();
